//
//  cli.cpp
//  Animera
//
//  Created by Indiana Kernick on 23/11/19.
//  Copyright © 2019 Indiana Kernick. All rights reserved.
//

#include "cli.hpp"

#include "strings.hpp"
#include "cli new.hpp"
#include "cli info.hpp"
#include "cli export.hpp"
#include "application.hpp"
#include <QtCore/qtextstream.h>

namespace {

const char usage[] =
R"(Usage:
    Animera
    Animera --help
    Animera --long-help
    Animera new <width> <height> [<format>]
    Animera open <file>
    Animera info [--layer-names --json] <file>
    Animera export)";

const char short_options[] =
R"(Options:
    -h, --help                Display this help message.
    --long-help               Display a detailed help message.
    <width>                   Width of the animation to create.
    <height>                  Height of the animation to create.
    <format>                  Format of the animation to create.
    <file>                    Animation file to open.
    --layer-names             Output the names of layers.
    -j, --json                Output info as JSON.)";

const char long_options[] =
R"(Options:
    -h, --help
        Display a brief help message.
    
    --long-help
        Display this help message.
    
    <width>
        Width (in pixels) of the animation to create.
    
    <height>
        Height (in pixels) of the animation to create.
    
    <format>
        Format of the animation to create. Valid formats are:
            rgba   (8-bit RGBA)
            index  (8-bit Indexed)
            gray   (8-bit Grayscale with alpha)
        This is "rgba" by default.
    
    --layer-names
        Outputs information about the layers. This includes the name, the number
        of cels and the visibility.
    
    -j, --json
        By default, animation info is outputted in a pleasant-for-humans format.
        When this option is present, animation info is outputted as JSON.
    
    -n, --name <pattern>
        Name pattern for the animation. By default this is "sprite_%000F".
        This pattern may contain format sequences.
        The available format sequences are:
            %F  frame number
            %L  layer number
        Zeros may appear after the % character to pad the number with zeros.
        Examples assuming that "e.animera" contains 2 layers and 2 frames:
            Animera export -n "a_%F" e.animera        a_0 a_1
            Animera export -n "b_%000F" e.animera     b_000 b_001
            Animera export -c -n "c_%L_%F" e.animera  c_0_0 c_0_1 c_1_0 c_1_1
    
    -d, --directory <path>
        Directory to write files to. By default this is ".". The output file
        paths are generated by concatenating this and the above options:
            <path> "/" <pattern> ".png"
        Paths ending with a / are accepted.
        
    -l, --layer <range>
        This is similar to the --frame option but for layers.
    
    -f, --frame <range>
        The range of frames to export. By default, all frames are exported. This
        may be a single frame such as 0 or an inclusive range such as 1..3.
        Either or both sides of the range may be omitted.
        Examples assuming an animation with 4 frames:
            1..2            frames 1 and 2
            ..2   or  0..2  frames 0, 1 and 2
            1..   or  1..3  frames 1, 2 and 3
            ..    or  0..3  frames 0, 1, 2 and 3
            1     or  1..1  frame 1
    
    -c, --no-composite
        By default, the cels that make up a frame are composited so that each
        frame is exported as a single image. If this option is present, layers
        are not composited and the cels that make up a frame are exported
        individually. The presence or absence of this option can affect the
        output formats available.
    
    -F, --format <format>
        The resulting output files are always PNGs. This option corresponds to
        the color type of the PNGs. The output formats available depend on the
        format of the input animation. Given the input format, these are the
        valid output formats (the first in each list is the default):
            RGBA
                rgba        (8-bit RGBA)
            Indexed (with --no-composite)
                index       (8-bit Indexed)
                gray        (8-bit Grayscale)
                monochrome  (1-bit Grayscale)
            Indexed (without --no-composite)
                rgba        (8-bit RGBA)
            Grayscale
                gray-alpha  (8-bit Grayscale with alpha)
                gray        (8-bit Grayscale)
                monochrome  (1-bit Grayscale)
    
    --visibility <mode>
        The visibility of a layer in the range (defined by the --layer option)
        affects whether it will be included in the export. This option defines
        how the visibility affects inclusion. There are three possible values:
            visible  Visible layers are included
            hidden   Hidden layers are included
            all      All layers are included
        By default, this is in "visible" mode.
    
    --scale-x <integer>
        The horizontal scale factor applied to each output image. The scale
        factor cannot be 0 but can be negative, in this case, the image is
        flipped horizontally. If this option is present, the --scale option
        cannot be.
    
    --scale-y <integer>
        The vertical scale factor applied to each output image. The scale factor
        cannot be 0 but can be negative, in this case, the image is flipped
        vertically. If this option is present, the --scale option cannot be.
    
    -s, --scale <integer>
        The scale factor applied to each output image. This option is equivalent
        to using the --scale-x and --scale-y options with the same scale factor.
        If this option is present, neither --scale-x nor --scale-y can be.
    
    -a, --angle <integer>
        The angle of rotation applied to each output image. The image can only
        be rotated in 90 degree increments. This means that --angle 1 will
        rotate clockwise by 90 degrees. The angle doesn't need to be within
        [0, 4] so --angle -3, --angle 1 and --angle 5 are all equivalent.
        The rotation is applied after the scale is applied.)";

}

CLI::CLI(int &argc, char **argv)
  : argc{argc}, argv{argv} {}

int CLI::exec() {
  docopt::Options flags;
  QTextStream console{stdout};
  if (Error err = parseArgs(flags); err) {
    console << "Command line error\n" << err.msg() << '\n';
    console << usage << '\n';
    return 1;
  }
  
  if (flags.at("--help").asBool()) {
    console << usage << "\n\n" << short_options << '\n';
    return 0;
  } else if (flags.at("--long-help").asBool()) {
    console << usage << "\n\n" << long_options << '\n';
    return 0;
  } else if (flags.at("new").asBool()) {
    return cliNew(argc, argv, flags);
  } else if (flags.at("open").asBool()) {
    return execOpen(flags);
  } else if (flags.at("info").asBool()) {
    return cliInfo(argc, argv, flags);
  } else if (flags.at("export").asBool()) {
    return cliExport(argc, argv);
  } else {
    return execDefault();
  }
}

Error CLI::parseArgs(docopt::Options &flags) const {
  // https://stackoverflow.com/a/10242200/4093378
  char **first = argv + 1;
  if (argc == 2 && std::strncmp(*first, "-psn_", 5) == 0) {
    ++first;
  }
  std::string doc = usage;
  doc += "\n\n";
  doc += short_options;
  try {
    flags = docopt::docopt_parse(doc, {first, argv + argc}, false, false);
  } catch (docopt::DocoptArgumentError &e) {
    return e.what();
  }
  return {};
}

int CLI::execDefault() const {
  Application app{argc, argv};
  app.waitForOpenEvent();
  return app.exec();
}

int CLI::execOpen(const docopt::Options &flags) const {
  Application app{argc, argv};
  app.openFile(toLatinString(flags.at("<file>").asString()));
  return app.exec();
}
